"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../utils/logger");
const sms_1 = require("./channels/sms");
const facebook_1 = require("./channels/facebook");
const whatsapp_1 = require("./channels/whatsapp");
const request = require("../utils/request");
/**
 * Client class with the features.
 */
class Client {
    /**
     * Returns a new `Client` that can be used to execute some functionality.
     *
     * @param token Zenvia platform token.
     * @param loggerInstance If you want, you can pass your log instance.
     */
    constructor(token, loggerInstance) {
        this.token = token;
        this.logger = new logger_1.Logger(loggerInstance);
    }
    /**
     * This method returns a channel type object.
     *
     * @param channel [[Channel]] of the instance that you want to create.
     * @returns [[Channel]] type instance.
     */
    getChannel(channel) {
        switch (channel) {
            case 'sms': return new sms_1.SmsChannel(this.token, this.logger);
            case 'facebook': return new facebook_1.FacebookChannel(this.token, this.logger);
            case 'whatsapp': return new whatsapp_1.WhatsAppChannel(this.token, this.logger);
            default: throw new Error('Unsupported channel');
        }
    }
    /**
     * This method returns a list of subscriptions.
     *
     * @returns A promise that resolves to an array of [[ISubscription]] objects.
     */
    async listSubscriptions() {
        const path = '/v1/subscriptions';
        return request.get(this.token, path, this.logger);
    }
    /**
     * This method creates a subscription.
     *
     * @param subscription An [[ISubscription]] object.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async createSubscription(subscription) {
        const path = '/v1/subscriptions';
        return request.post(this.token, path, subscription, this.logger);
    }
    /**
     * This method returns a subscription.
     *
     * @param id Subscription identifier.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async getSubscription(id) {
        const path = `/v1/subscriptions/${id}`;
        return request.get(this.token, path, this.logger);
    }
    /**
     * This method updates a subscription.
     *
     * @param id Subscription identifier.
     * @param subscription An [[IPartialSubscription]] object.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async updateSubscription(id, subscription) {
        const path = `/v1/subscriptions/${id}`;
        return request.patch(this.token, path, subscription, this.logger);
    }
    /**
     * This method deletes a subscription.
     *
     * @param id Subscription identifier.
     * @returns A promise that resolves to an [[ISubscription]] object.
     */
    async deleteSubscription(id) {
        const path = `/v1/subscriptions/${id}`;
        return request.del(this.token, path, this.logger);
    }
    /**
     * This method returns a list of templates.
     *
     * @returns A promise that resolves to an array of [[ITemplate]] objects.
     */
    async listTemplates() {
        const path = '/v1/templates';
        return request.get(this.token, path, this.logger)
            .then((templates) => {
            templates.forEach((template) => {
                template.channels.forEach((channel) => {
                    channel.type = channel.type.toLowerCase();
                });
            });
            return templates;
        });
    }
    /**
     * This method returns a template.
     *
     * @param id Template identifier.
     * @returns A promise that resolves to an [[ITemplate]] object.
     */
    async getTemplate(id) {
        const path = `/v1/templates/${id}`;
        return request.get(this.token, path, this.logger)
            .then((template) => {
            template.channels.forEach((channel) => {
                channel.type = channel.type.toLowerCase();
            });
            return template;
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map